> 1989年，蒂姆·伯纳斯 - 李（Tim Berners-Lee）在论文中提出可以在互联网上构建超链接文档，并提出了三点.

**URI**：统一资源标识符。互联网的唯一ID

**HTML**：超文本文档

**HTTP**:传输超文本的文本传输协议

## 目录
- [HTTP应用场景](#HTTP应用场景)
- [什么是HTTP](#什么是HTTP)
- [不同版本的HTTP](#不同版本的HTTP)
- [HTTP报文详解](#HTTP报文详解)

---

### HTTP应用场景
<http_application_sence.png>

### 什么是HTTP
HTTP(hypertext transport protocol)翻译过来为**"超文本传输协议"**，文本可以理解为简单的字符文字组合，也可以理解为更为复杂的音频或者图像等。那么将这个词语拆分为三个部分。

- [ ] "超文本"和"文本"相比多了一个字"超"，这样看来比文本丰富，因为它可以将多种文本/图像等进行**混合**，更重要的是可以从一个文本**跳转**到另一个文本(文本连接)。

- [ ] "传输"，传输的过程中需要沟通，沟通即可能一对一沟通也可能一对多沟通(进行内容协商)，无论怎么样，参加沟通的人数>1，想尽一切一切办法更快更好的完成相应的任务。

- [ ] "协议"，无规矩不成方圆，做机密项目之前需要签署保密协议，找工作要签"三方协议"，三方协议是学校，公司，和个人组成的协议，都是为了让大家受一定的约束，违反了即有相应的惩罚。

### 不同版本的HTTP

#### - [ ] HTTP/0.9

当时网络资源匮乏，0.9版本相对简单，采用纯文本格式，且设置为**只读**，所以当时只能使用"Get"的方式从服务器获得HTML文档，响应以后则关闭。如下所示
```
GET /Mysite.html
```
响应中只包含了文档本身。响应内容无响应头，无错误码，无状态码，可以说是"裸奔"。
```
<HTML>
	Hello world
</HTML>
HTTP/1.0
```
此时HTTP/0.9请求过程如下

- 1.应用层的HTTP建立在传输层的TCP之上并运用TCP可靠性等特性，先三次握手建立连接

- 2.客户端请求建立连接(此时只有GET)

- 3.服务端响应请求，数据以 ASCII 字符流返回给客戶端

- 4.传输完成，断开连接。

<HTTP_0.9.png>

#### - [ ]  HTTP1.0

随着时代的进步，仅仅文本的传输无法满足需求，更多情况需要采用图文的方式才能生动的表达出自己的观点。随着1995年开发出Apache，同时其他的多媒体等技术发展迅速，从而进一步的促使HTTP新功能的出现。HTTP1.0在1996年诞生，增加了一下几个方面：

- 之前只有Get方法，现在增加Post(加参数)，Head方法

- 加入协议版本号，同时添加文件处理类型

- 加入HTTP Header，让HTTP处理请求更加灵活

- 增加响应状态码，标记出错的原因

- 提供国际化(不同语言)支持

==典型的请求过程==

```
GET /image.html HTTP/1.0
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)

200 OK
Date: Tue, 17 Nov 2020 09:15:31 GMT
Content-Type: text/html
<HTML> 
一个包含图片的页面
  <IMG SRC="/image.gif">
</HTML>
```

==HTTP1.0通信过程==

<HTTP_1.0.png>

#### - [ ] HTTP1.1

1995年是不平凡的一年，网景公司和微软开启浏览器大战，谁都想当老大。1999年HTTP/1.1发布并成为标准，写入RFC，以为以后不管是网关还是APP等，只要你要使用HTTP，就得遵守这个标准。

- 继续增加了PUT等方法

- 允许持久连接

随着文件越来越大，图片等信息越来越复杂，如果每一次上传下载文件都需要建立连接断开连接的过程将增加大量的开销。为此，提出了**持久连接**，也就是一次TCP连接可以具有多个HTTP请求。当然持久连接是可选择的，如果考虑关闭，只需要使用Connecttion:close关闭即可。长连接如下图所示

<HTTP_1_1.png>

- 强制要求Host头

我们知道，在电商系统中，经常会因为促销活动导致流量飙升，为了缓解流量，其中有种方法即**加缓存或者加服务器**。如果是单台服务器负载过大，数据库可能分库分表。数据结构算法中分而治之方法亦是如此。那么HTTP中，同样的道理，如果文件太大，就大文件切分为小文件块发送。

#### - [ ] HTTP 2

HTTP/1.1的出现，几年间出来大量牛掰的互联网公司，发展实在是太快，但是HTTP1.1中这几点成为诟病

- 原因1 TCP自带慢启动
顾名思义，"慢启动"从0到1循循渐进。轿车启动不会按下按钮就直接起飞，而是缓慢调节到适合的速度。这不是挺好的？为什么会带来性能问题呢。我们知道一个页面有静态数据，动态页面，很多小文件在加载的过程中就会直接发起请求，这样导致太多的请求都会经历慢启动过程，花费时间太多。

- 原因2 多条TCP连接带宽竞争
带宽固定，多条TCP连接同时发起竞争带宽资源，由于各个TCP连接之间没有通信机制，也无法得知哪些资源优先级更高，从而导致想快速下载的资源反而延迟下载。

- 原因3 头部阻塞
阻塞，在网络编程中，我们采用异步，多路复用(epoll)方式尽量让cpu少等待多干事。在HTTP1.1中，虽然大家共用了一条TCP通道，但是第一个请求没有结束，第二请求就可能阻塞等待，也就是说**不能同时发送接收数据**。那么一个网页很多数据文件，如果能够同时发出请求，让部分数据文件能够得到响应并预处理，这样就大大的利用了带宽和cpu的资源。基于这些因素，在HTTP2中出现了新的方案

- [ ] 如何解决头部阻塞呢？

HTTP是**一问一答**的模式，大家都在这个队列排队导致堵塞，那就多个队列并发进行，也就是"对同一个域名发起多个长连接"。举个例子，在火车站排队买票的时候，如果只有一个窗口可用，大家只能苦等，多开几个窗口就可缓解这个问题。

这个时候用户数 x 并发数(上限6-8)已经不错得效果，但是互联网速度太快，火车站就这么大，窗口也就这么多，怎么办，建新的火车站进行**分流**(大部分城市都有什么东站 西站)。在这里叫做"域名分片"，使用多个域名，这些域名指向同一服务器。

#### - [ ] HTTP 3

HTTP/2看似很完美了吧，但是Google轮子哥可不服，其他人在研究HTTP/2的时候，它们就在琢磨QUIC。那QUIC有啥牛掰的地方呢

> QUIC是Google开发的一个基于UDP且能像TCP一样具有可靠性特点的协议。具备像HTTP/2一样的应用数据二进制分帧传输。其主要解决的问题有两个。

- 进一步解决线头阻塞问题。通过独立不同流，让各个流之间实现相互独立传输，互不干扰

- 切换网络时的连接保持。wifi和3G/4G经常需要来回切换。基于TCP的协议，会因为网络的切换导致IP地址的改变。而基于UDP的QUIC协议，及时切换也可以恢复之前与服务器的连接。(这里推荐大家可以去看看MPTCP)


### HTTP报文详解
> 客户端与服务端进行交互的信息为报文。客户端为请求报文，服务端为响应报文。我们先用wireshark抓一个博客看看

<message.png>
```
GET /article/12 HTTP/1.1
Host: www.xxx.cn
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: SESSION=so9nlsvenminor5abs65sh9dsa
HTTP/1.1 200 OK
Server: nginx
Date: Sun, 17 May 2020 17:04:29 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
X-Powered-By: blade-2.0.6-BETA
Content-Encoding: gzip
```

请求报文

<ask_msg.png>


请求报文通常由三部分组成：

- 起始行：描述请求或者响应的基本信息

- 头部字段集合：key-value形式说明报文

- 消息正文：实际传输诸如图片等信息。

**1.请求方法**
||请求方法|方法描述|
|-|-|-|
|1|GET|请求服务器某一资源|
|2|POST|向指定资源提交数据进行处理请求，数据包含在请求体中|
|3|HEAD|用于确认URI的有效性及资源更新的日期时间，不返回报文主体，只返回报文文首部|
|4|PUT|用于传输文件，将文件内容放进报文主体中，保存到URI指定位置上|
|5|DELETE|与PUT相反，请求URI删除指定资源|
|6|OPTIONS|查询针对请求URI指定的资源支持的方法|
|7|TRACE|用于追踪路径。发送请求时，发送请求时，首部字段MAX-FORWARDS会指定一个数值，每经过一个服务器后，该数值减1.当该数值位0时，停止传输，最后接收到的服务器响应|
|8|CONNECT|用于在与代理服务器通信时建立隧道，实现隧道协议进行TCP通信|