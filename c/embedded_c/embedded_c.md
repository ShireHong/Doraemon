
#### 面试题1：
> 用find 写出查找/opt/kernel目录下(包括子目录)文件名为Kconfig的命令。
```
find /opt/kernel -name "Kconfig"
```
 

#### 面试题2：
> 用 Vi 编译器底行命令模式实现字符串替换，把当前文件中的“xiaodai”全部替换成“banzhang”。
```
:s/xiaodai/banzhang/g
```

#### 面试题3：
> 变量的声明和定义有什么区别?
```
变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
变量声明：用于向程序表明变量的类型和名字。
区别：定义也是声明，extern声明不是定义。定义分配存储空间，而声明不会。通过使用extern关键字声明变量名而不定义它。 事实上它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。
只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。
```

#### 面试题4：
> sizeof是库函数吗？sizeof 和 strlen 的区别？
```
1 sizeof是操作符，而strlen是库函数；
2 sizeof的参数可以为任意变量或类型，而strlen必须以char*做参数，且字符串必须以‘/0’结尾；
3 数组名用作sizeof参数时不会退化，而用作strlen参数时就会退化成指针；
4 大部分编译器在编译期计算sizeof的值，所以其结果可以用作常量，例如可以定义数组的维数，而strlen一定要到运行期才会被计算；
5 sizeof的参数如果是变量名，可以不加括号，因为其是运算符不是函数，而strlen必须加括号；
6 在计算字符串的长度时strlen(str)+1==sizeof(str)。
```

#### 面试题5：
> 链表和数组有什么区别
```
1、数组在内存中是逐个存放的，也就是说倘若数组的第一个元素在地址A,则数组第二个元素就在地址A+1。
而链表则不是，链表每个节点没有相对固定的位置关系。某个节点在地址A其后的节点不一定是A+1,而在内存的其他空闲区域，呈现一种随机的状态。

2、数组一旦显式的被申明后，其大小就固定了，不能动态进行扩充。而链表则可以，可以动态生成节点并且添加到已有的链表后面。

3、链表灵活，但是空间和时间额外耗费较大；数组大小固定，元素位置固定，但是操作不灵活，且容易浪费空间，但是时间耗费较小，尤其是元素变化不大的时候效率很高。双向链表比单向的更灵活，但是空间耗费也更大
 1)链表的特性是在中间任意位置添加删除元素的都非常的快，不需要移动其它的元素。 
 2)链表顾名思义，要把各个元素链接起来才算撒。   
 3)通常链表每一个元素都要保存一个指向下一个元素的指针（单链表）。   
 4)双链表的化每个元素即要保存到下一个元素的指针，还要保存一个上一个元素的指针。   
 5)循环链表则把最后一个元素中保存下一个元素指针指向第一个元素。

4、数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素,每个数组元素都有一个编号,
这个编号叫做下标,我们可以通过下标来区别这些元素。数组元素的个数有时也称之为数组的长度。

5、数组查改方便,链表增删效率高。
``` 

#### 面试题6：
> 简述队列和栈的异同
```
栈和队列的异同  
1、共同点：
--- 栈和队列都是线性表，都是限制了插入删除点的线性表（或者说是控制了访问点的线性表）
--- 都是只能在线性表的端点插入和删除

2、不同点：
--- 栈的插入和删除都在线性表的同一个端点，该点通称栈顶，相应地，不能插入删除的另一个端点通称栈底，其特性是后进先出
--- 队列在线性表的表头插入，表尾删除，表头一般称队头，表尾一般称队尾，其特性是先进先出
总结：
相同之处：n个（同类）数据元素的有限序列称为线性表。线性表的特点是数据元素之间存在“一对一”的关系，栈和队列都是操作受限制的线性表，他们和线性表一样，数据元素之间都存在“一对一”的关系

不同之处：栈只允许在一段进行插入或删除操作的线性表，其最大的特点是“先进后出或后进的先出”；
对列是只允许在一端进行插入，另一端进行删除操作的线性表，其最大的特点是“先进先出”。
```

#### 面试题7：
> 有以下语句: char a=3, b=6, c; c = a^b<<2; 则c的二进制值是_____。
```
a = 0000 0011
b = 0000 0110
c = 0000 0011^(0000 0110<<2) = 0000 0011 ^ 0001 1000 = 0001 1011

```

#### 面试题8：
> 如何打印出当前源文件的文件名以及源文件的当前行号？
```
printf("%s %d\n",__func__,__LINE__);
```
 

#### 面试题9：
> 假设某个函数的原型为：void foo( int x, int y ); 该函数分别被C编译器和C++编译器编译后在符号库中的名字是什么？
```
作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。如题函数为 void foo( int x, int y );   
该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。
_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。
```

#### 面试题10：
> 在QT程序中可以调用被C 编译器编译后的函数吗?如果可以怎么实现？
```
可以，通过加“extern "C"” 连接申明,被extern "C"修饰的变量和函数是按照C语言方式编译和连接的
```

#### 面试题11：
> .h头文件中的ifndef/define/endif 的作用？＃i nclude<file.h> 与 ＃include "file.h"的区别？
 ```
 1. 防止该头文件被重复引用。 
 2. 前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。
 ``` 

#### 面试题12：
> 结构与联合有和区别？
```
1、结构和联合都是由多个不同的数据类型成员组成,但在任何同一时刻,联合中只存放了一个被选中的成员（所有成员共用一块地址空间),而结构的所有成员都存在（不同成员的存放地址不同）。
2、对于联合的不同成员赋值,将会对其它成员重写,原来成员的值就不存在了,而对于结构的不同成员赋值是互不影响的。
```

#### 面试题13：
> 全局变量和局部变量可否同名，他们是否有区别？如果有，是什么区别？      
```
可以
1.生存周期不同 
全局变量:全局区（静态区）（static）：全局变量和静态变量是存储在一起的，初始化过的全局变量和静态变量在同一块区域，未初始化的全局变量和静态变量存放在一块相邻的区域内。此区域由系统在程序结束后释放 
局部变量： 放在堆栈中。由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈

2.作用范围不同 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回

```

#### 面试题14：
> static有什么用途？ static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
```
1.static全局变量只初使化一次，防止在其他文件单元中被引用; 
2.static局部变量只被初始化一次，下一次依据上一次结果值；
3.static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
```


#### 面试题15：
> 什么是预编译,何时需要预编译?
```
1、预编译又称为预处理 , 是做些代码文本的替换工作。
2、处理以# 开头的指令 , 比如拷贝 #include 包含的文件代码，#define 宏定义的替换，条件编译等，就是为编译做的预备工作的阶段。
3、主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。
4、C 编译系统在对程序进行通常的编译之前，首先进行预处理。
```

#### 面试题16：
>有数组定义int a[2][2]={{1},{2,3}};则a[0][1]的值为多少？。
```
a[0][1] = 0;
```

#### 面试题17：
> 请计算sizeof的值。
```
char  str[] = “Hello” ;
char   *p = str ;
int     n = 10;
请计算
sizeof (str ) =__6__
sizeof ( p ) =___4_
sizeof ( n ) =___4__

void Func ( char str[100])
{
    请计算sizeof( str ) = 4
}
 void *p = malloc( 100 ); 请计算sizeof ( p ) = 4
 char *str[]={“Hello”,”HI”, “\x0”};
请计算：
sizeof(str)   = 12
sizeof(str[0]) = 4
```
#### 面试题18：
> 头文件中有如下宏定义，
#define DECLARE_TASKLET(name, func, data)  \    
struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }
.c源文件中有如下语句:
static DECLARE_TASKLET(btn_tasklet,
                    btn_tasklet_func,
                    (unsigned long)&mydata);
请写出预编译后，该语句展开的结果.
```
static struct tasklet_struct btn_tasklet={NULL, 0, ATOMIC_INIT(0), btn_tasklet_func, (unsigned long)&mydata};
```

#### 面试题19：
> 写一个程序，以递归方式反序输出一个字符串。如给定字符串“abc”输出“cba ”。
```
#include<stdio.h>

void print_str(char *str)
{
    if(*str == 0)
        return;
    
    print_str(str+1);
    printf("%c",*str);
}

```

#### 面试题20：
> 对于一个字节(8bit)的无符号整形变量，求二进制表示中“1”的个数，要求算法执行效率尽可能地高。
```
1,暴力法，一位一位的移
2，查表法，把8位数的所有1的个数数出来
3，a &=a-1;直到a=0；1个个数等于循环次数，效率比较高。
还有三种牛逼的：
4，平行算法
5，完美法
6，位标志法
```

#### 面试题21：
> 参数传递有哪些形式？寄存器和堆栈传递各有什么优缺点?
```
1、编译优化、调用性能、接口设计。
2、每种体系结构及对应的编译器对参数传递都有自己的规定。参数传递并非总是通过堆栈进行的，参数入栈出栈是需要耗费时间的，编译器总是尽量优化利用寄存器来传递参数，因为寄存器的访问效率要高，但当参数过多时，将放弃优化从而用栈传递参数。因此为了提高调用性能，应尽量减少参数个数，太多时可以将所有参数重新定义为一个结构体，利用结构体指针来传递参数。在函数接口设计时应考虑硬件平台和编译器的特性，以灵活定义参数形式
```
#### 面试题22：
> define宏语句和inline函数有什么区别？
```
相同点：
两者都是可以加快程序运行效率，使代码变得更加通用

不同点：
内联函数的调用是传参，宏定义只是简单的文本替换
内联函数可以在程序运行时调用，宏定义是在程序编译进行
内联函数有类型检测更加的安全，宏定义没有类型检测
内联函数在运行时可调式，宏定义不可以
内联函数可以访问类的成员变量，宏不可以
类中的成员函数是默认的内联函数

```

#### 面试题23：
> char a[5][4]，a的地址为0，问printf(“%d”，a[4]+3）值
```
a的地址为0，
```

#### 面试题24：
> 编写一个宏，实现判断数组a元素的个数。
```
#define CALC(a) sizeof(a)/sizeof(a[0])
``` 

#### 面试题25：
> .#define DOUBLE(x) x+x  ，i = 5*DOUBLE(5)；  i  是多少？
```
i = 5*5+5

```


#### 面试题26:
> i++一下代码的输出结果是？
int i = 1;
int j = 2;
int k = i+++j;
cout << k << endl；
```
不想看到这种题目
```
#### 面试题27：
> 下面代码输出是什么？为什么
void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
```
unsigned int 和 int 相加会把 int转化为unsigned int,所以a+b会很大

常见转换

float-double
char,short-int
int-unsigned-long-double
从左边转到右边
```

#### 面试题28：
> 关于动态申请内存的问题
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}
void Test(void) 
{
    char *str = NULL;
    GetMemory(str);   
    strcpy(str, "hello world");
    printf(str);
}
请问运行 Test 函数会有什么样的结果？
```
错误，str为NULL，函数会报错
```
请问运行 Test 函数会有什么样的结果？
```
char *GetMemory(void)
{  
    char p[] = "hello world";
    return p;
}
void Test(void)
{
    char *str = NULL;
    str = GetMemory();
    printf(str);
}

报错，不能返回局部指针
```

#### 面试题30：
> 请问运行 Test 函数会有什么样的结果？
```
void GetMemory2(char **p, int num)
{
    *p = (char *)malloc(num);
}
void Test(void)
{
    char *str = NULL;
    GetMemory(&str, 100);
    strcpy(str, "hello"); 
    printf(str);
}

能运行，但是会内存泄漏
```

#### 面试题31：
> 请问运行 Test 函数会有什么样的结果？
```
void Test(void)
{
    char *str = (char *) malloc(100);
    strcpy(str, “hello”);
    free(str); 
    if(str != NULL) 
    {
        strcpy(str, “world”); 
        printf(str);
    }
}
内存释放后，在使用后果不堪设想
```

#### 面试题32：
> 用预处理指令#define  声明一个常数，用以表明 1 年中有多少秒（忽略闰年问题）
```
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
```

#### 面试题33：
> C 语言中结构化程序设计的三种基本控制结构
```
顺序结构、
选择结构、
循环结构。
顺序结构的程序设计是最简单的，只要按照解决问题的顺序写出相应的语句就行，它的执行顺序是自上而下，依次执行。
选择结构用于判断给定的条件，根据判断的结果判断某些条件，根据判断的结果来控制程序的流程。
循环结构可以减少源程序重复书写的工作量，用来描述重复执行某段算法的问题，这是程序设计中最能发挥计算机特长的程序结构 。循环结构可以看成是一个条件判断语句和一个向回转向语句的组合。
```

#### 面试题34：
> 请说出 const 与#define相比，有何优点？
```
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。
```

####面试题35：
> 简述数组与指针的区别？
```
1.存储方式：数组只能在静态存储区或栈上被创建，而指针可以随时随地的指向任意类型的内存块。
2.内存容量：用运算符sizeof可以计算出数组的容量（字节数）。sizeof(p)，p为指针，得到的是一个指针变量的字节数，而不是指针指向内存的容量。
3.内容上的差别：char a[]="hello"数组指向每一个数组元素；而char *p="world"，p指向的是字符串的首地址。

```

#### 面试题36：
> main 函数执行完毕后，是否可能会再执行一段代码，给出说明？
```
继续运行，处理一些退出函数
```
#### 面试题37：
> 如果编写一个标准 strlen 函数
```
easy
```
#### 面试题38：
> 如何引用一个已经定义过的全局变量？
```
extern
头文件
```

#### 面试题39：
> do……while 和 while……do 有什么区别？
```
先循环在判断
先判断再循环
```

#### 面试题40：
> 写一个“标准”宏 MIN
```
#define MIN(X,Y) ({__typeof__(X) _x=(X);__typeof__(Y) _y=(Y); _x<_y?_x:_y;})
```
#### 面试题41：
> typedef 和 define 有什么区别
```
(1)原理不同
#define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。
typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。
(2)功能不同
typedef用来定义类型的别名，起到类型易于记忆的功能。另一个功能是定义机器无关的类型。如定义一个REAL的浮点类型，在目标机器上它可以获得最高的精度：typedef long double REAL， 在不支持long double的机器上，看起来是这样的，typedef double REAL，在不支持double的机器上，是这样的，typedef float REAL
#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
(3)作用域不同#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。
(4)对指针的操作不同
```

#### 面试题42：
    Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。
例如，思考一下下面的例子：

#define dPS struct s * 
typedef struct s * tPS; 
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
```
typedef 更好，见题41
```

#### 面试题43：
> int (*s[10])(int)  表示的是什么
```
函数指针数组，且数组中每一个元素都是参数为int，返回为int的函数
```

#### 面试题44:
写出 bool  、int、  float、指针变量与“零值”比较的 if 语句bool 型数据：
```
bool型就只有true和false两个结果，这里bool型的零值对应的是false；
int型的零值就是0；
float型的零值约为0.000001，即为1e-6;
指针变量的零值就是NULL；
所以判断分别写为：
if(a)
if(0 == a)
if(fabs(a) <= zero)
if(NULL == p)
```

#### 面试题45：
请写出以下代码的打印结果

#include<stdio.h>
void main( void )
{
    int a[5]={1,2,3,4,5};
    int *ptr=(int *)(&a+1);
    printf("%d,%d",*(a+1),*(ptr-1));
    return;
}
```
&a+1 已经超出数组 若 a=0 &a + 1=20
2 5
```

#### 面试题46：
设置地址为 0x67a9 的整型变量的值为 0xaa66
```
(*((int*)0x67a9)) = 0xaa66
```


#### 面试题47：
> 引用与指针有什么区别？[面试题44](#面试题44)
